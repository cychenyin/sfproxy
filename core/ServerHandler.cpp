// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#ifndef GETMS_
#define GetMs(start) (double) (ganji::util::time::GetCurTimeUs() - start) / CLOCKS_PER_SEC * 1000
#define DiffMs(end, start) (double) (end - start) / CLOCKS_PER_SEC * 1000
#endif

#include <iostream>
// #include <time.h>
// #include <sys/time.h>

#include "../thrift/RegistryProxy.h"
#include "ganji/util/time/time.h"

#include "ZkClient.h"
#include "RegistryCache.h"
#include "RequestPool.h"
#include "ClientPool.h"

using namespace std;

namespace FinagleRegistryProxy {

class ServerHandler: virtual public RegistryProxyIf {

private:
	RegistryCache *cache;
	ClientPool *pool;
	string *root;
	string split;

public:
	ServerHandler(string zkhosts) {
		root = new string("/soa/services");
		cache = new RegistryCache();
		pool = new ClientPool(new ZkClientFactory(zkhosts, cache));
		split = "/";
	}

	~ServerHandler() {
		if (pool) {
			delete pool;
			pool = 0;
		}
		if (cache) {
			delete cache;
			cache = 0;
		}
		if (root) {
			delete root;
			root = 0;
		}
	}
	void get(std::string& _return, const std::string& serviceName) {
#ifdef DEBUG_
		// cout << "frproxy get method called. " << serviceName << endl;
		long start = ganji::util::time::GetCurTimeUs();
#endif
		ZkClient *client = (ZkClient*) pool->open();
#ifdef DEBUG_
		long open = ganji::util::time::GetCurTimeUs();
#endif
		if (!client) {
			_return = "";
			cout << " get error, fail to open zk client. pool exhausted maybe. " << endl;
			return;
		}

		string path = *root + split + serviceName;

		vector<Registry>* pvector = cache->get(path.c_str());
		if (pvector == 0 || pvector->size() == 0) {
			cache->dump();
			client->get_children(serviceName);
			pvector = cache->get(serviceName.c_str());
			cout << " get cache miss." << endl;
		}
#ifdef DEBUG_
		long get = ganji::util::time::GetCurTimeUs();
		int id = client->id();
#endif
		client->close(); // must
#ifdef DEBUG_
		long close = ganji::util::time::GetCurTimeUs();
#endif
		if (pvector && pvector->size() > 0) {
			_return = Registry::to_json_string(*pvector);
		} else
			_return = "";
#ifdef DEBUG_
		cout << " pool total=" << pool->size() << " used=" << pool->used() << " idle=" << pool->idle() << " client id="
				<< id << endl;
		long serial = ganji::util::time::GetCurTimeUs();
		cout << " get total cost=" << DiffMs(serial, start) << " open=" << DiffMs(open, start) << " get="
				<< DiffMs(get, open) << " close" << DiffMs(close, get) << " serial=" << DiffMs(serial, close) << endl;
#endif
	}

	void remove(std::string& _return, const std::string& serviceName, const std::string& host, const int32_t port) {
		cout << "remove called. not supported now." << endl;
	}

	void warm() {
#ifdef DEBUG_
		long start = ganji::util::time::GetCurTimeUs(); // CLOCKS_PER_SEC
#endif
		ZkClient *client = (ZkClient*) pool->open();
#ifdef DEBUG_
		long open = ganji::util::time::GetCurTimeUs(); // CLOCKS_PER_SEC
#endif
		if (!client) {
			cout << " warm error, fail to open zk client." << endl;
			return;
		}
		vector<string> names = client->get_all(*root);
		vector<string>::iterator it = names.begin();
		while (it != names.end()) {
			client->get_children(*root + "/" + (*it));
			++it;
		}
		client->close();

//		for(int i = 0;i<100000000; i++) {
//			i +=10;
//			i -=10;
//		}
#ifdef DEBUG_
		long end = ganji::util::time::GetCurTimeUs(); // CLOCKS_PER_SEC
		cout << "warm " << names.size() << " proxy cost=" << DiffMs(end, start) << "ms. open client cost="
				<< DiffMs(open, start) << endl;
		cache->dump();
#endif

	}
};

} /* namespace FinagleRegistryProxy  */
