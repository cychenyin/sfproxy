// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <boost/smart_ptr/shared_ptr.hpp>
#include <concurrency/Mutex.h>
#include <unistd.h>
#include <iterator>
#include <map>
#include <string>
#include <utility>
#include <vector>

#include "../frproxy.h"
#include "Registry.h"

#ifndef DiffMs_
#define DiffMs(end, start) ((double) (end - start) / CLOCKS_PER_SEC * 1000)
#endif

#include <iostream>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <concurrency/Exception.h>
#include <concurrency/PosixThreadFactory.h>
#include <concurrency/Thread.h>
#include <concurrency/ThreadManager.h>

#include "../thrift/RegistryProxy.h"

#include "ZkClient.h"
#include "RegistryCache.h"
#include "ClientPool.h"
#include "SkipBuffer.h"
#include "../log/logger.h"

using namespace std;
using namespace apache::thrift::concurrency;
using boost::shared_ptr;

namespace FinagleRegistryProxy {

class WarmTask: public Runnable {
private:
	ClientPool *pool;
	string zk_root;
	ZkClient *c;
public:
	WarmTask(ClientPool *pool, string zkRoot) :
			pool(pool), zk_root(zkRoot) {
		c = 0;
	}

	~WarmTask() {
	}

	void run() {
		c = (ZkClient*) pool->open();
		if (c) {
			vector<string> names = c->get_all(zk_root);
			vector<string>::iterator it = names.begin();
			while (it != names.end()) {
				if (c)
					c->get_children(zk_root + "/" + (*it));
				++it;
			}
			c->close();
		}
	}
};

class RegisterTask: public Runnable {
private:
	ClientPool *pool;
	string node_name;
	ZkClient *c;

public:
	RegisterTask(ClientPool *pool, string node_name) :
			pool(pool), node_name(node_name) {
		c = 0;
	}

	~RegisterTask() {
	}

	void run() {
		// ZkClient *client = (ZkClient*) pool->open();
		c = (ZkClient*) pool->open();
		if (c) {
			stringstream ss;
			ss << "/soa";
			c->create_pnode(ss.str());
			ss << "/proxies";
			c->create_pnode(ss.str());
			ss << "/" << node_name;
			int res = c->create_enode(ss.str(), "");
			if (res != 0) {
				logger::warn("register_self zoo_create error, path=%s", ss.str().c_str());
			}
		}
	}
};

class ZkReadTask: public Runnable {
private:
	ClientPool *pool;
	string zkpath;
	SkipBuffer *skip_buf;
	ZkClient *c;
public:
	ZkReadTask(ClientPool *pool, string zkpath, SkipBuffer *skip_set) :
			pool(pool), zkpath(zkpath), skip_buf(skip_set) {
		c = 0;
	}

	~ZkReadTask() {
	}
	void run() {
		logger::warn("async get request: %s", zkpath.c_str());
		c = (ZkClient*) pool->open();
		if (c) {
			c->get_children(zkpath);
			c->close(); // must
		} else {
			cout << " get error, fail to open zk client. pool exhausted maybe. " << endl;
		}
		skip_buf->erase(zkpath);
	}
};
// class serverHandler::Task

class ServerHandler: virtual public RegistryProxyIf {

private:
	RegistryCache *cache;
	ClientPool *pool;
	string *root;
	string split;
	SkipBuffer *skip_buf;
	shared_ptr<ThreadManager> threadManager;
	int async_wait_timeout; // in ms
	int async_exec_timeout; // in ms
	string hostname;
public:
	ServerHandler(string zkhosts) {
		root = new string("/soa/services");
		cache = new RegistryCache();
		pool = new ClientPool(new ZkClientFactory(zkhosts, cache));
		split = "/";
		init_thread_pool();
		async_wait_timeout = -1; // Return immediately if pending task count exceeds specified max
		async_exec_timeout = 1000;
		skip_buf = new SkipBuffer(async_exec_timeout);
		init_hostname();
	}

	~ServerHandler() {
		if (pool) {
			delete pool;
			pool = 0;
		}
		if (cache) {
			delete cache;
			cache = 0;
		}
		if (root) {
			delete root;
			root = 0;
		}
		delete skip_buf;
		skip_buf = 0;

		threadManager->stop();
	}

	void get(std::string& _return, const std::string& serviceName) {

#ifdef DEBUG_
//		cout << "frproxy get method called. " << serviceName << endl;
		uint64_t start = utils::now_in_us();
		uint64_t got(start), zk_retrieve_start(start), zk_retrieve_end(start), serial(start);
#endif
		string path = *root + split + serviceName;
		vector<Registry>* pvector = cache->get(path.c_str());
		if (pvector == 0 || pvector->size() == 0) { // not hit cache, then update cache
#ifdef DEBUG_
//			cout << " async get request: " << path << endl;
				zk_retrieve_start = utils::now_in_us();
#endif
			logger::warn("async get request: %s", path.c_str());
			// if getting from zk, then skip
			pair<map<string, uint32_t>::iterator, bool> insert = skip_buf->insert(path);
			if (insert.second) {
				try {
					threadManager->add(shared_ptr<ZkReadTask>(new ZkReadTask(pool, path, skip_buf)), async_wait_timeout);
					// (new ZkReadTask(pool, path, skip_buf))->run();
				} catch (TooManyPendingTasksException &ex) {
					logger::warn("too many pending zk task in thread pool. %s", ex.what());
					cout << "too many pending zk task in thread pool. " << ex.what() << endl;
				}
			}
#ifdef DEBUG_
			zk_retrieve_end = utils::now_in_us();
#endif
		}
#ifdef DEBUG_
		got = utils::now_in_us();
#endif
		if (pvector && pvector->size() > 0) {
			_return = Registry::to_json_string(*pvector);
		} else
			_return = "";
#ifdef DEBUG_
		serial = utils::now_in_us();
//		cout << " pool total=" << pool->size() << " used=" << pool->used() << " idle=" << pool->idle() << endl;
//		cout << " get total cost=" << DiffMs(serial, start) << " got=" << DiffMs(got, start) << " zk retrieve="
//				<< DiffMs(zk_retrieve_end, zk_retrieve_start) << " serial=" << DiffMs(serial, got) << endl;
//		cache->dump();
#endif
	}

	void remove(std::string& _return, const std::string& serviceName, const std::string& host, const int32_t port) {
		// cout << "remove called. not supported now." << endl;
	}

	void warm() {
//		string path = "/soa/services/testservice";
//		Runnable *t = new ZkReadTask(pool, path, skip_buf);
//		t->run();
//		delete t;
//		t = 0;
//
//		t = new WarmTask(pool, *root);
//		t->run();
//		delete t;
//		t = 0;

		threadManager->add(shared_ptr<WarmTask>(new WarmTask(pool, *root)));
	}

	void register_self(int port) {
		return;
		stringstream name;
		name << this->hostname << ":" << port;
		try {
			threadManager->add(shared_ptr<RegisterTask>(new RegisterTask(pool, name.str())), 0l, 0l);
		} catch (TooManyPendingTasksException &e) {
			logger::warn("too many pending task occured  in thread pool when register self. %s", e.what());
			cout << "too many pending task occured  in thread pool when register self. " << e.what() << endl;
		}
	}
private:
//	void read_zk(string svc_name) {
//		int i;
//		for (i = 0; i < 3; i++)
//			cout << svc_name << " " << i << endl;
//	}

	void init_thread_pool() {
		threadManager = ThreadManager::newSimpleThreadManager(1, 100);
		shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
		threadManager->threadFactory(threadFactory);
		threadManager->start();
	}
	void init_hostname() {
		int size = 128;
		char *buf = new char[size];
		for (int i = 0; i < size; i++) {
			buf[i] = 0;
		}
		gethostname(buf, size);
		// copy to string
		this->hostname = string(buf);
		delete buf;
		buf = 0;
	}

public:
	void memtest() {
		int i = 1;
		int j = 2;
		int k = 3;
		cout << "stack" << endl;
		cout << &i << endl;
		cout << &j << endl;
		cout << &k << endl;

		int a[3];
		cout << &a[0] << endl;
		cout << &a[1] << endl;
		cout << &a[2] << endl;

		cout << a[3] << endl;
		cout << a[5] << endl;

		cout << "heap, new" << endl;

		int* b = new int[3];
		cout << &b[0] << endl;
		cout << &b[1] << endl;
		cout << &b[2] << endl;
	}

};
// class ServerHandler

} /* namespace FinagleRegistryProxy  */
