// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#ifndef GETMS_
#define GetMs(start) ((double) (ganji::util::time::GetCurTimeUs() - start) / CLOCKS_PER_SEC * 1000)
#define DiffMs(end, start) ((double) (end - start) / CLOCKS_PER_SEC * 1000)
#endif

#include <iostream>
// #include <time.h>
// #include <sys/time.h>

#include "../thrift/RegistryProxy.h"
#include "ganji/util/time/time.h"

#include "ZkClient.h"
#include "RegistryCache.h"
#include "RequestPool.h"
#include "ClientPool.h"

using namespace std;

namespace FinagleRegistryProxy {

class ServerHandler: virtual public RegistryProxyIf {

private:
	RegistryCache *cache;
	ClientPool *pool;
	string *root;
	string split;
	set<string> *skip_set;
	apache::thrift::concurrency::Mutex mutex;
public:
	ServerHandler(string zkhosts) {
		root = new string("/soa/services");
		cache = new RegistryCache();
		pool = new ClientPool(new ZkClientFactory(zkhosts, cache));
		split = "/";
		skip_set = new set<string>();
	}

	~ServerHandler() {
		if (pool) {
			delete pool;
			pool = 0;
		}
		if (cache) {
			delete cache;
			cache = 0;
		}
		if (root) {
			delete root;
			root = 0;
		}
		delete skip_set;
		skip_set = 0;
	}

	void get(std::string& _return, const std::string& serviceName) {
//		_return = "";
//		return;
#ifdef DEBUG_
		cout << "frproxy get method called. " << serviceName << endl;
		long start = ganji::util::time::GetCurTimeUs();
		long open = start, get = start, id = start, close = start;
#endif
		string path = *root + split + serviceName;
		vector<Registry>* pvector = cache->get(path.c_str());
		if (pvector == 0 || pvector->size() == 0) { // not hit cache, then update cache
			// if block, then skip
			set<string>::iterator found = skip_set->find(serviceName);
			if (found == skip_set->end()) {
				mutex.lock();
				skip_set->insert(serviceName);
				mutex.unlock();
				ZkClient *client = (ZkClient*) pool->open();
#ifdef DEBUG_
				long open = ganji::util::time::GetCurTimeUs();
#endif
				if (client) {
					client->get_children(path);
					pvector = cache->get(path.c_str());
#ifdef DEBUG_
					cout << " get cache miss." << endl;
					long get = ganji::util::time::GetCurTimeUs();
					id = client->id();
#endif
					mutex.lock();
					//found = skip_set->find(serviceName);
					skip_set->erase(found);
					mutex.unlock();
					client->close(); // must
				} else {
					// TODO ... log it
					cout << " get error, fail to open zk client. pool exhausted maybe. " << endl;
					return;
				}
#ifdef DEBUG_
				long close = ganji::util::time::GetCurTimeUs();
#endif
			}
		}
		if (pvector && pvector->size() > 0) {
			_return = Registry::to_json_string(*pvector);
		} else
			_return = "";
#ifdef DEBUG_
		cout << " pool total=" << pool->size() << " used=" << pool->used() << " idle=" << pool->idle() << endl;
		long serial = ganji::util::time::GetCurTimeUs();
		cout << " client id=" << id << " get total cost=" << DiffMs(serial, start) << " open=" << DiffMs(open, start)
		<< " get=" << DiffMs(get, open) << " close" << DiffMs(close, get) << " serial=" << DiffMs(serial, close)
		<< endl;
//		cache->dump();
#endif
	}

	void remove(std::string& _return, const std::string& serviceName, const std::string& host, const int32_t port) {
		// cout << "remove called. not supported now." << endl;
	}

	void warm() {
#ifdef DEBUG_
		long start = ganji::util::time::GetCurTimeUs(); // CLOCKS_PER_SEC
#endif
		ZkClient *client = (ZkClient*) pool->open();
#ifdef DEBUG_
		long open = ganji::util::time::GetCurTimeUs(); // CLOCKS_PER_SEC
#endif
		if (!client) {
			cout << " warm error, fail to open zk client." << endl;
			return;
		}
		vector<string> names = client->get_all(*root);
		vector<string>::iterator it = names.begin();
		while (it != names.end()) {
			client->get_children(*root + "/" + (*it));
			++it;
		}
		client->close();

#ifdef DEBUG_
		long end = ganji::util::time::GetCurTimeUs(); // CLOCKS_PER_SEC
		cache->dump();
		cout << "warm " << names.size() << " proxy cost=" << DiffMs(end, start) << "ms. open client cost="
		<< DiffMs(open, start) << endl;
#endif

	}
};

} /* namespace FinagleRegistryProxy  */
