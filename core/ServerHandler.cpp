// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#ifndef GETMS_
#define GetMs(start) ((double) (utils::now_in_us() - start) / CLOCKS_PER_SEC * 1000)
#define DiffMs(end, start) ((double) (end - start) / CLOCKS_PER_SEC * 1000)
#endif

#include <iostream>
// #include <time.h>
// #include <sys/time.h>

#include "concurrency/PosixThreadFactory.h"
#include "concurrency/Thread.h"
#include "concurrency/ThreadManager.h"

#include "../thrift/RegistryProxy.h"

#include "ZkClient.h"
#include "RegistryCache.h"
#include "ClientPool.h"
#include "../log/logger.h"

using namespace std;
using namespace apache::thrift::concurrency;
using boost::shared_ptr;

namespace FinagleRegistryProxy {

// safe to insert & erase
class SimpleSafeSet: public set<string> {
private:
	Mutex mutex;
public:
	SimpleSafeSet() {

	}
	~SimpleSafeSet() {
	}
	std::pair<iterator, bool> insert(const value_type& __x) {
		mutex.lock();
		pair<iterator, bool> ret = set<string>::insert(__x);
		mutex.unlock();
		return ret;
	}

	void erase(iterator __position) {

		mutex.lock();
		set<string>::erase(__position);
		mutex.unlock();
	}
};
// SimpleSafeSet

class WarmTask: public Runnable {
private:
	ClientPool *pool;
	string zk_root;

public:
	WarmTask(ClientPool *pool, string zkRoot) :
			pool(pool), zk_root(zkRoot) {
	}

	~WarmTask() {
	}

	void run() {
#ifdef DEBUG_
		// long start = utils::now_in_us(); // CLOCKS_PER_SEC
		uint64_t start = utils::now_in_us();
#endif
		ZkClient *client = (ZkClient*) pool->open();
#ifdef DEBUG_
		uint64_t open = utils::now_in_us();
#endif
		if (!client) {
			cout << " warm error, fail to open zk client." << endl;
			return;
		}
		vector<string> names = client->get_all(zk_root);
		vector<string>::iterator it = names.begin();
		while (it != names.end()) {
			client->get_children(zk_root + "/" + (*it));
			++it;
		}
		client->close();

#ifdef DEBUG_
		uint64_t end = utils::now_in_us();
		cout << "warm " << names.size() << " proxy cost=" << DiffMs(end, start) << "ms. open client cost="
				<< DiffMs(open, start) << endl;
#endif
	}
};

class GetZkTask: public Runnable {
private:
	ClientPool *pool;
	string zkpath;
	set<string> *skip_set;
public:
	GetZkTask(ClientPool *pool, string zkpath, set<string> *skip_set) :
			pool(pool), zkpath(zkpath), skip_set(skip_set) {
	}

	~GetZkTask() {
	}

	void run() {
		ZkClient *client = (ZkClient*) pool->open();
		if (client) {
			client->get_children(zkpath);
			client->close(); // must
			set<string>::iterator it = skip_set->find(zkpath);
			if (it != skip_set->end())
				skip_set->erase(it);
		} else {
			cout << " get error, fail to open zk client. pool exhausted maybe. " << endl;
			return;
		}
	}
};
// class serverHandler::Task

class ServerHandler: virtual public RegistryProxyIf {

private:
	RegistryCache *cache;
	ClientPool *pool;
	string *root;
	string split;
	SimpleSafeSet *skip_set;
	shared_ptr<ThreadManager> threadManager;
	int async_timeout; // in ms
public:
	ServerHandler(string zkhosts) {

		root = new string("/soa/services");
		cache = new RegistryCache();
		pool = new ClientPool(new ZkClientFactory(zkhosts, cache));
		split = "/";
		skip_set = new SimpleSafeSet();
		init_pool();
		async_timeout = 100;
	}

	~ServerHandler() {

		if (pool) {
			delete pool;
			pool = 0;
		}
		if (cache) {
			delete cache;
			cache = 0;
		}
		if (root) {
			delete root;
			root = 0;
		}
		delete skip_set;
		skip_set = 0;

		threadManager->stop();
	}

	void get(std::string& _return, const std::string& serviceName) {
//		_return = "";
//		return;
#ifdef DEBUG_
		cout << "frproxy get method called. " << serviceName << endl;
		uint64_t start = utils::now_in_us();
		uint64_t got = start, got_try_start, get_try_end, serial = start;
#endif
		string path = *root + split + serviceName;
		vector<Registry>* pvector = cache->get(path.c_str());
		if (pvector == 0 || pvector->size() == 0) { // not hit cache, then update cache
#ifdef DEBUG_
			cout << " async getting " << path << endl;
			got_try_start = utils::now_in_us();
#endif
			logger::warn("async getting %s", path.c_str());
			// if getting from zk, then skip
			set<string>::iterator found = skip_set->find(serviceName);
			if (found == skip_set->end()) {
				pair<set<string>::iterator, bool> insert = skip_set->insert(serviceName);
				if (insert.second) {
					threadManager->add(shared_ptr<GetZkTask>(new GetZkTask(pool, path, skip_set)),
							async_timeout);
				}
			}
#ifdef DEBUG_
			get_try_end = utils::now_in_us();
#endif
		}
#ifdef DEBUG_
		got = utils::now_in_us();
#endif
		if (pvector && pvector->size() > 0) {
			_return = Registry::to_json_string(*pvector);
		} else
			_return = "";
#ifdef DEBUG_
		serial = utils::now_in_us();
		cout << " pool total=" << pool->size() << " used=" << pool->used() << " idle=" << pool->idle() << endl;
		cout << " get total cost=" << DiffMs(serial, start) << " got=" << DiffMs(got, start) << " got's try="
				<< DiffMs(get_try_end, got_try_start) << " serial=" << DiffMs(serial, got) << endl;
//		cache->dump();
#endif
	}

	void remove(std::string& _return, const std::string& serviceName, const std::string& host, const int32_t port) {
		// cout << "remove called. not supported now." << endl;
	}

	void warm() {
		threadManager->add(shared_ptr<WarmTask>(new WarmTask(pool, *root)),
				async_timeout * 1000);
	}
private:
	void read_zk(string svc_name) {
		int i;
		for (i = 0; i < 3; i++)
			cout << svc_name << " " << i << endl;

	}

	void init_pool() {
		threadManager = ThreadManager::newSimpleThreadManager(1);
		shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
		threadManager->threadFactory(threadFactory);
		threadManager->start();
	}
};
// class ServerHandler

} /* namespace FinagleRegistryProxy  */
