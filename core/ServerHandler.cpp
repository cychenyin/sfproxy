// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#ifndef GETMS_
#define GetMs(start) ((double) (utils::now_in_us() - start) / CLOCKS_PER_SEC * 1000)
#define DiffMs(end, start) ((double) (end - start) / CLOCKS_PER_SEC * 1000)
#endif

#include <iostream>
#include <sstream>
// #include <time.h>
// #include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>
#include "concurrency/PosixThreadFactory.h"
#include "concurrency/Thread.h"
#include "concurrency/ThreadManager.h"

#include "../thrift/RegistryProxy.h"

#include "ZkClient.h"
#include "RegistryCache.h"
#include "ClientPool.h"
#include "../log/logger.h"

using namespace std;
using namespace apache::thrift::concurrency;
using boost::shared_ptr;

namespace FinagleRegistryProxy {

// safe to insert & erase
class SimpleSafeSet: public set<string> {
private:
	Mutex mutex;
public:
	SimpleSafeSet() {
	}
	~SimpleSafeSet() {
	}
	std::pair<iterator, bool> insert(const value_type& __x) {
		mutex.lock();
		pair<iterator, bool> ret = set<string>::insert(__x);
		mutex.unlock();
		return ret;
	}

	void erase(iterator __position) {

		mutex.lock();
		set<string>::erase(__position);
		mutex.unlock();
	}
};
// SimpleSafeSet

class WarmTask: public Runnable {
private:
	ClientPool *pool;
	string zk_root;

public:
	WarmTask(ClientPool *pool, string zkRoot) :
			pool(pool), zk_root(zkRoot) {
	}

	~WarmTask() {
	}

	void run() {
		// long start = utils::now_in_us(); // CLOCKS_PER_SEC
		uint64_t start = utils::now_in_us();
#ifdef DEBUG_
#endif
		ZkClient *client = (ZkClient*) pool->open();
		uint64_t open = utils::now_in_us();
#ifdef DEBUG_
#endif
		if (!client) {
			cout << " warm error, fail to open zk client." << endl;
			return;
		}
		vector<string> names = client->get_all(zk_root);
		vector<string>::iterator it = names.begin();
		while (it != names.end()) {
			client->get_children(zk_root + "/" + (*it));
			++it;
		}
		client->close();

		uint64_t end = utils::now_in_us();
		cout << "warm " << names.size() << " proxy cost=" << DiffMs(end, start) << "ms. open client cost="
				<< DiffMs(open, start) << endl;
#ifdef DEBUG_
#endif
	}
};

class GetZkTask: public Runnable {
private:
	ClientPool *pool;
	string zkpath;
	set<string> *skip_set;
public:
	GetZkTask(ClientPool *pool, string zkpath, set<string> *skip_set) :
			pool(pool), zkpath(zkpath), skip_set(skip_set) {
	}

	~GetZkTask() {
	}

	void run() {
#ifdef DEBUG_
		cout << " async getting: " << zkpath << endl;
#endif
		logger::warn("async get request: %s", zkpath.c_str());

		ZkClient *client = (ZkClient*) pool->open();
//		cout << "async says before sleep: " << utils::now_in_us() << endl;
//		usleep(20000);
//		cout << "async says after  sleep: " << utils::now_in_us() << endl;
		if (client) {
			client->get_children(zkpath);
#ifdef DEBUG_
			cout << "debugggggggggggggggggggggggggggggggggggg " << endl;
			client->debug();
			cout << pool->stat() << endl;
			cout << "debugggggggggggggggggggggggggggggggggggg end" << endl;
#endif
			client->close(); // must
			set<string>::iterator it = skip_set->find(zkpath);
			if (it != skip_set->end()) {
				skip_set->erase(it);
			}
		} else {
			cout << " get error, fail to open zk client. pool exhausted maybe. " << endl;
			return;
		}
	}
};
// class serverHandler::Task

class ServerHandler: virtual public RegistryProxyIf {

private:
	RegistryCache *cache;
	ClientPool *pool;
	string *root;
	string split;
	SimpleSafeSet *skip_set;
	shared_ptr<ThreadManager> threadManager;
	int async_timeout; // in ms
	string hostname;
public:
	ServerHandler(string zkhosts) {

		root = new string("/soa/services");
		cache = new RegistryCache();
		pool = new ClientPool(new ZkClientFactory(zkhosts, cache));
		split = "/";
		skip_set = new SimpleSafeSet();
		init_pool();
		async_timeout = 100;
		init_hostname();
	}

	~ServerHandler() {

		if (pool) {
			delete pool;
			pool = 0;
		}
		if (cache) {
			delete cache;
			cache = 0;
		}
		if (root) {
			delete root;
			root = 0;
		}
		delete skip_set;
		skip_set = 0;

		threadManager->stop();
	}

	void get(std::string& _return, const std::string& serviceName) {
//		_return = "";
//		return;
#ifdef DEBUG_
		cout << "frproxy get method called. " << serviceName << endl;
		uint64_t start = utils::now_in_us();
		uint64_t got(start), zk_retrieve_start(start), zk_retrieve_end(start), serial(start);
#endif
		string path = *root + split + serviceName;
		vector<Registry>* pvector = cache->get(path.c_str());
		if (pvector == 0 || pvector->size() == 0) { // not hit cache, then update cache
#ifdef DEBUG_
			cout << " async get request: " << path << endl;
			zk_retrieve_start = utils::now_in_us();
#endif
			logger::warn("async get request: %s", path.c_str());
			// if getting from zk, then skip
			set<string>::iterator found = skip_set->find(path);
			if (found == skip_set->end()) {
				pair<set<string>::iterator, bool> insert = skip_set->insert(path);
				if (insert.second) {
					threadManager->add(shared_ptr<GetZkTask>(new GetZkTask(pool, path, skip_set)), async_timeout,
							async_timeout);
				}
			}
#ifdef DEBUG_
			zk_retrieve_end = utils::now_in_us();
#endif
		}
#ifdef DEBUG_
		got = utils::now_in_us();
#endif
		if (pvector && pvector->size() > 0) {
			_return = Registry::to_json_string(*pvector);
		} else
			_return = "";
#ifdef DEBUG_
		serial = utils::now_in_us();
		cout << " pool total=" << pool->size() << " used=" << pool->used() << " idle=" << pool->idle() << endl;
		cout << " get total cost=" << DiffMs(serial, start) << " got=" << DiffMs(got, start) << " zk retrieve="
				<< DiffMs(zk_retrieve_end, zk_retrieve_start) << " serial=" << DiffMs(serial, got) << endl;
//		cache->dump();
#endif
	}

	void remove(std::string& _return, const std::string& serviceName, const std::string& host, const int32_t port) {
		// cout << "remove called. not supported now." << endl;
	}

	void warm() {
		threadManager->add(shared_ptr<WarmTask>(new WarmTask(pool, *root)), async_timeout * 1000, async_timeout * 1000);
	}
	void register_self(int port) {
		ZkClient *client = (ZkClient *) pool->open();
		stringstream ss;
//		ss << "{\"name\":\"proxy\",\"host\":\"" << hostname << "\",\"port\":" << port << " }";
//		string data = ss.str();
//		char p[20];
//		itoa(port, p, 10);
		ss << "/soa";
		client->create_pnode(ss.str());
		ss << "/proxies";
		client->create_pnode(ss.str());
		ss << "/" << hostname << ":" << port;
		int res = client->create_enode(ss.str(), "");
		if (res != 0) {
			logger::warn("register_self zoo_create error, path=%s", ss.str().c_str());
		}
#ifdef DEBUG_
		cout << "self register path:" << ss.str() << endl;
#endif
	}
private:
	void read_zk(string svc_name) {
		int i;
		for (i = 0; i < 3; i++)
			cout << svc_name << " " << i << endl;
	}

	void init_pool() {
		threadManager = ThreadManager::newSimpleThreadManager(1);
		shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
		threadManager->threadFactory(threadFactory);
		threadManager->start();
	}
	void init_hostname() {
		//
		int size = 128;
		char *hostname = new char[size];
		for (int i = 0; i < size; i++) {
			hostname[i] = 0;
		}
		gethostname(hostname, size);
		// copy to string
		this->hostname = string(hostname);
		delete hostname;
		hostname = 0;
	}
};
// class ServerHandler

} /* namespace FinagleRegistryProxy  */
