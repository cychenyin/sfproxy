// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <iostream>


#include "../thrift/RegistryProxy.h"

#include "ZkClient.h"
#include "RegistryCache.h"
#include "RequestPool.h"

using namespace std;
//using namespace FinagleRegistryProxy;

namespace FinagleRegistryProxy {


class ServerHandler: virtual public RegistryProxyIf {

private:
	RegistryCache *cache;
	ZkClient *client;
public:
	ServerHandler(string zkhosts) {
		cache = &RegistryCache();
		client = &ZkClient(zkhosts, cache);
	}

//	RequestPool rpool;
//	ClientPool cpool;

	void get(std::string& _return, const std::string& serviceName) {
		cout << "frproxy get method called." << serviceName << endl;
		_return = "asdf";
//		vector<Registry>* pvector = cache->get(serviceName);
//		if (pvector == 0 || pvector->size() == 0) {
//			client->UpdateServices(serviceName);
//			pvector = cache->get(serviceName);
//		}
//		if (pvector && pvector->size() > 0) {
//			_return = Registry::toJsonStringx(*pvector);
//		} else
//			_return = "";
		// cout << "	" << _return << endl;
		Registry r;
		r.name = "/soa/testserivce";
		r.host = "127.0.0.1";
		r.port = 9999;
		r.ctime = time(NULL) / 1000;
//		_return = Registry::toJsonString(r);
		vector<Registry> v;
		v.push_back(r);
		v.push_back(Registry("/soa/testserivce", "localhost", 8888));

		_return = Registry::toJsonString(v);
	}

	void remove(std::string& _return, const std::string& serviceName, const std::string& host, const int32_t port) {

		// Your implementation goes here
		// printf("remove\n");
		cout << "remove called" << endl;
	}
};

} /* namespace FinagleRegistryProxy  */
